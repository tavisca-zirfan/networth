1. Autoboxing and Unboxing

Useful when wanting to add primitives to Collections...since collections can only store references and not data

for (int i = -300; i < 300; i++) {
			Integer p = i;
			Integer q = i;
			if (p == q) {
				System.out.println(p + "==" + q);
			} else {
				System.out.println(p + "<>" + q);
			}
		}

Autoboxing only blurs the lines between primitives and objects. They are not interchangeable

Integer(2) == Integer (2) --> Unboxed to int
but Integer(128) <> Integer(128) --> treated as object references

2. Generics

Previously we run into the issue of runtime exceptions when objects from collections are incorrectly cast

With Generics we provide a hint to the compiler of the type of collection we want to set it to and we get compile time checking across all the code. Generics uses type erasure in that upon compilation, the type information is lost...but this makes the code interoperable with legacy code.

Generics are useful in collections and other scenarios

List<String> myList is not a sub-type of List<Object> myList
--> this is intentionally so to prevent you from adding an object to the list and then incorrectly casting it to a String

While you cannot add an object of a any type to a list you can always get an object from a list and cast it.


3. Principles of OOP and their design patterns:

a) OCP - Open Close Principle

Modules should be open to extension and closed to modifications.
Patterns: Dynamic Polymorphism (composed of Interface implemented by concrete objects)
	  Static Polymorphism (Generics)

b) LSP - Liskov Substitution Principle

Subclasses should be substitutable for their base classes
Patterns: design by contract (comments)

c) DIP - Dependency Inversion Principle

Depend on abstractions and not concretions. (ie do not depend on volatility)

d) ISP - Interface Segregation Principle

Many client specific interfaces are better than one general purpose interface. Changes to one clients interface methods will not require that all clients be recompiled/redeployed.

e) SRP - Single Responsibility Principle

There should never be more than one reason for a class to change



RCP
===
An extension point defines what all that it requires (icon, shortcut etc.)

It may also require the class that needs to be called upon activation (for menus)

In addition the Class must implement the interface expected by the extension point. The interface establishes the communication channel between the plugin providing the extension and that consuming the extension.

